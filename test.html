<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Linear Function Plot</title>
    <script src='https://cdn.plot.ly/plotly-2.32.0.min.js'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js'></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="static/css/index.css">
    <style>
        body {
            display: flex;
            align-items: center;
            height: 100vh;
            font-family: 'Noto Sans', sans-serif;
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="grid-container">
        <div class="plot_1">
            <div class="controls">
                <label for="m">m = <span id="m-value">1</span></label>
                <input type="range" id="m" min="-3" max="3" value="1.05" step="0.01">
                <label for="n">n = <span id="n-value">1</span></label>
                <input type="range" id="n" min="-4" max="4" value="-2.67" step="0.01">
            </div>
            <div id="plot"></div>
            <script>
                const mSlider = document.getElementById('m');
                const nSlider = document.getElementById('n');
                const mValue = document.getElementById('m-value');
                const nValue = document.getElementById('n-value');

                function updatePlot() {
                    const m = parseFloat(mSlider.value);
                    const n = parseFloat(nSlider.value);

                    mValue.textContent = m;
                    nValue.textContent = n;

                    const xValues = [];
                    const yValues = [];

                    for (let x = -1.1; x <= 1.1; x += 0.01) {
                        xValues.push(x);
                        const a = 5 / (0.45 * Math.abs(Math.tanh(m)) + 1e-1)
                        const b = 0.6 * Math.tanh(n)
                        const y = 1 / (1 + Math.exp(-a*(x-b)));
                        yValues.push(y);
                    }

                    const trace = {
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#fc8b00'},
                    };

                    const layout = {
                        xaxis: {range: [-1.1, 1.1], fixedrange: true, tickmode: 'linear', dtick: 0.5},
                        yaxis: {range: [-0.1, 1.1], fixedrange: true, tickmode: 'linear', dtick: 0.25},
                        margin: {t: 10, b: 20, l: 30, r: 10},
                    };
                    Plotly.newPlot('plot', [trace], layout, {staticPlot: true});
                }

                mSlider.addEventListener('input', updatePlot);
                nSlider.addEventListener('input', updatePlot);

                updatePlot();
            </script>
        </div>

        <div id="attention_map"></div>
    <script>
        // Constants
        const path = 'static/images/frame_diff.png';
        const img = new Image();
        img.src = path;

        let aspectRatioAttention = img.height / img.width;
        img.width /= 20;
        img.height = img.width * aspectRatioAttention;
        const layout = {
                scene: {
                    aspectmode: 'manual',
                    aspectratio: {x: aspectRatioAttention, y: 1, z: 0.618},
                    xaxis: {visible: false},
                    yaxis: {visible: false},
                    camera: {eye: {x: 0, y: 0, z: 1.3}},
                    dragmode: 'turntable',
                },
                margin: {t: 0, b: 0, l: 0, r: 0}
            };

        // Load and process the image
        img.onload = function() {
            // Initial plot
            updateAttentionMap(img, layout);
        };

        function computeZData(imageData, m = 1.05, n = -2.67) {
            const a_ = 5 / (0.45 * Math.abs(Math.tanh(m)) + 1e-1);
            const b_ = 0.6 * Math.tanh(n);
            const z_data = [];
            const width = imageData.width;
            const height = imageData.height;

            for (let i = width; i > 0; i--) {
                const col = [];
                for (let j = height; j > 0 ; j--) {
                    const k = (j * width + i) * 4;
                    const r = imageData.data[k] / 255;
                    const g = imageData.data[k + 1] / 255;
                    const b = imageData.data[k + 2] / 255;
                    var gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    gray = (gray - 0.5) * 2;
                    gray = 1 / (1 + Math.exp(-a_*(gray-b_)));
                    col.push(gray);
                }
                z_data.push(col);
            }

            return z_data;
        }

        function updateAttentionMap(image, layout, m = 1.05, n = -2.67) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0, image.width, image.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const trace = {
                z: computeZData(imageData, m, n),
                type: 'surface',
                colorscale: 'peach',
                cmin: -1.5,
                cmax: 1.5,
                lighting: {diffuse: 0.2},
                showscale: false,
            };
            Plotly.react('attention_map', [trace], layout, {displayModeBar: false});
        }

        // Utility function to debounce another function
        function debounce(func, delay) {
            let debounceTimer;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(context, args), delay);
            };
        }

        // Updated event listener with debouncing
        mSlider.addEventListener('input', debounce(function() {
            updateAttentionMap(img, layout, parseFloat(mSlider.value), parseFloat(nSlider.value));
        }, 10));

        nSlider.addEventListener('input', debounce(function() {
            updateAttentionMap(img, layout, parseFloat(mSlider.value), parseFloat(nSlider.value));
        }, 10));
    </script>


        <div id="output_frame"></div>
        <script>
            // Initialize images
            const output_path = 'static/images/frame_0.png';
            const output_img = new Image();
            output_img.src = output_path;

            const diff_path = 'static/images/frame_diff.png';
            const diff_img = new Image();
            diff_img.src = diff_path;

            // Load and process images
            output_img.onload = function() {
                resizeImage(output_img);

                diff_img.onload = function() {
                    resizeImage(diff_img);

                    processImages();
                };
            };

            function resizeImage(img) {
                var aspectRatio = img.width / img.height;
                img.height /= 5;
                img.width = img.height * aspectRatio;
            }

            function processImages() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                canvas.width = output_img.width;
                canvas.height = output_img.height;

                ctx.drawImage(output_img, 0, 0, canvas.width, canvas.height);
                const output_imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const output_data = output_imageData.data;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(diff_img, 0, 0, canvas.width, canvas.height);
                const diff_imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const diff_data = diff_imageData.data;

                const a_ = 5 / (0.45 * Math.abs(Math.tanh(1.05)) + 1e-1);
                const b_ = 0.6 * Math.tanh(-2.67);

                for (let i = 0; i < output_data.length; i += 4) {
                    let diff_gray = 0.299 * diff_data[i] + 0.587 * diff_data[i + 1] + 0.114 * diff_data[i + 2];
                    diff_gray = (diff_gray - 128) * 2 / 255; // Normalized and shifted
                    diff_gray = 1 / (1 + Math.exp(-a_ * (diff_gray - b_)));
                    output_data[i] *= diff_gray;
                    output_data[i + 1] *= diff_gray;
                    output_data[i + 2] *= diff_gray;
                }

                ctx.putImageData(output_imageData, 0, 0);

                const output_trace = {
                    x: Array.from({length: canvas.width}, (_, i) => i),
                    y: Array.from({length: canvas.height}, (_, i) => i),
                    z: Array.from({length: canvas.height}, (_, i) => 
                    output_data.slice(i * canvas.width * 4, (i + 1) * canvas.width * 4)
                                .filter((_, j) => j % 4 !== 3) // Remove alpha channel
                                .map(v => v / 255)), // Normalize
                    type: 'heatmap',
                    colorscale: 'gray',
                    showscale: false
                };

                const output_layout = {
                    xaxis: {visible: false},
                    yaxis: {visible: false},
                    margin: {t: 0, b: 0, l: 0, r: 0}
                };

                Plotly.newPlot('output_frame', [output_trace], output_layout, {staticPlot: true});
            }
        </script>
    </div>
</body>
</html>
